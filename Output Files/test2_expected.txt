Token           Lexeme         
-----------------------------------
    <Rat25S> -> $$ <OptFunctionDefinitions> $$ <OptDeclarationList> $$ <StatementList> $$
Token: separator       Lexeme: $$
    <OptFunctionDefinitions> -> <FunctionDefinitions>
    <FunctionDefinitions> -> <Function> [<FunctionDefinitions>]
    <Function> -> function id ( <OptParameterList> ) <OptDeclarationList> <Body>
Token: keyword         Lexeme: function
Token: identifier      Lexeme: max_of_three
Token: separator       Lexeme: (
    <OptParameterList> -> <ParameterList>
    <ParameterList> -> <Parameter> [ , <ParameterList> ]
    <Parameter> -> <IDs> <Qualifier>
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: a
    <Qualifier> -> integer | boolean | real
Token: keyword         Lexeme: integer
Token: separator       Lexeme: ,
    <ParameterList> -> <Parameter> [ , <ParameterList> ]
    <Parameter> -> <IDs> <Qualifier>
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: b
    <Qualifier> -> integer | boolean | real
Token: keyword         Lexeme: integer
Token: separator       Lexeme: ,
    <ParameterList> -> <Parameter> [ , <ParameterList> ]
    <Parameter> -> <IDs> <Qualifier>
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: c
    <Qualifier> -> integer | boolean | real
Token: keyword         Lexeme: integer
Token: separator       Lexeme: )
    <OptDeclarationList> -> <DeclarationList>
    <DeclarationList> -> <Declaration> ; [<DeclarationList>]
    <Declaration> -> <Qualifier> <IDs>
    <Qualifier> -> integer | boolean | real
Token: keyword         Lexeme: integer
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: max
Token: separator       Lexeme: ;
    <Body> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> [else <Statement>] endif
Token: keyword         Lexeme: if
Token: separator       Lexeme: (
    <Condition> -> <Expression> <Relop> <Expression>
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: a
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
    <Relop> -> == | != | > | < | <= | =>
Token: operator        Lexeme: >
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: b
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> [else <Statement>] endif
Token: keyword         Lexeme: if
Token: separator       Lexeme: (
    <Condition> -> <Expression> <Relop> <Expression>
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: a
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
    <Relop> -> == | != | > | < | <= | =>
Token: operator        Lexeme: >
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: c
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Assign>
    <Assign> -> id = <Expression> ;
Token: identifier      Lexeme: max
Token: operator        Lexeme: =
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: a
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: else
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Assign>
    <Assign> -> id = <Expression> ;
Token: identifier      Lexeme: max
Token: operator        Lexeme: =
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: c
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: endif
Token: separator       Lexeme: }
Token: keyword         Lexeme: else
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> [else <Statement>] endif
Token: keyword         Lexeme: if
Token: separator       Lexeme: (
    <Condition> -> <Expression> <Relop> <Expression>
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: b
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
    <Relop> -> == | != | > | < | <= | =>
Token: operator        Lexeme: >
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: c
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Assign>
    <Assign> -> id = <Expression> ;
Token: identifier      Lexeme: max
Token: operator        Lexeme: =
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: b
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: else
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Assign>
    <Assign> -> id = <Expression> ;
Token: identifier      Lexeme: max
Token: operator        Lexeme: =
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: c
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: endif
Token: separator       Lexeme: }
Token: keyword         Lexeme: endif
    <Statement> -> <Return>
    <Return> -> return ; | return <Expression> ;
Token: keyword         Lexeme: return
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: max
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: separator       Lexeme: $$
    <OptDeclarationList> -> <DeclarationList>
    <DeclarationList> -> <Declaration> ; [<DeclarationList>]
    <Declaration> -> <Qualifier> <IDs>
    <Qualifier> -> integer | boolean | real
Token: keyword         Lexeme: integer
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: x
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: y
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: z
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: maxNum
Token: separator       Lexeme: ;
Token: separator       Lexeme: $$
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Scan>
    <Scan> -> scan ( <IDs> ) ;
Token: keyword         Lexeme: scan
Token: separator       Lexeme: (
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: x
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: y
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: z
Token: separator       Lexeme: )
Token: separator       Lexeme: ;
    <Statement> -> <Assign>
    <Assign> -> id = <Expression> ;
Token: identifier      Lexeme: maxNum
Token: operator        Lexeme: =
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id ( <IDs> )
Token: identifier      Lexeme: max_of_three
Token: separator       Lexeme: (
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: x
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: y
Token: separator       Lexeme: ,
    <IDs> -> id [ , <IDs> ]
Token: identifier      Lexeme: z
Token: separator       Lexeme: )
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: ;
    <Statement> -> <Print>
    <Print> -> print ( <Expression> ) ;
Token: keyword         Lexeme: print
Token: separator       Lexeme: (
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: maxNum
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
Token: separator       Lexeme: ;
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> [else <Statement>] endif
Token: keyword         Lexeme: if
Token: separator       Lexeme: (
    <Condition> -> <Expression> <Relop> <Expression>
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> id
Token: identifier      Lexeme: maxNum
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
    <Relop> -> == | != | > | < | <= | =>
Token: operator        Lexeme: ==
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> integer|real
Token: integer         Lexeme: 0
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Print>
    <Print> -> print ( <Expression> ) ;
Token: keyword         Lexeme: print
Token: separator       Lexeme: (
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> true|false
Token: keyword         Lexeme: true
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: else
    <Statement> -> <Compound>
    <Compound> -> { <StatementList> }
Token: separator       Lexeme: {
    <StatementList> -> <Statement> [<StatementList>]
    <Statement> -> <Print>
    <Print> -> print ( <Expression> ) ;
Token: keyword         Lexeme: print
Token: separator       Lexeme: (
    <Expression> -> <Term> <ExpressionPrime>
    <Term> -> <Factor> <TermPrime>
    <Factor> -> <Primary>
    <Primary> -> true|false
Token: keyword         Lexeme: false
    <TermPrime> -> epsilon
    <ExpressionPrime> -> epsilon
Token: separator       Lexeme: )
Token: separator       Lexeme: ;
Token: separator       Lexeme: }
Token: keyword         Lexeme: endif
Token: separator       Lexeme: $$
Token: eof             Lexeme: 
